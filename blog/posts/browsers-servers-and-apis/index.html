<!DOCTYPE html><html lang="en"><head><title>johnhenry.github.io -- Weblog: Browses, Servers, and APIs</title><link rel="canonical" href="https://johnhenry.github.io/undefined"><meta name="description" content="Using servers in the browsers"><meta name="robots" content="index,follow"><meta name="theme-color" content="343233"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta charset="utf-8"><meta name="keywords" content="John Henry,John Henry's personal website,personal website personal,website,github,github.io, johnhenry, johnhenry.github.io,science, math,programming,engineering,experiments,programming"><meta name="author" content="John"><style type="text/css">
      @import "https://johnhenry.github.io/lib/css/universal-unstyled-links/0.0.0/index.css";
      @import "https://johnhenry.github.io/lib/css/universal-box-sizing/0.0.0/index.css";
      @import "/style/index.css";
    </style><link rel="icon" href="/image/iajh.png" type="image/x-icon"><script type="module">
      import "https://johnhenry.github.io/lib/js/css-variables-mouse/0.0.0/index.mjs";
      import "https://johnhenry.github.io/lib/js/css-variables-scroll/0.0.0/index.mjs"
    </script><link rel="apple-touch-icon" sizes="512x512" href="/images/iajh.512.png"><link rel="apple-touch-icon" sizes="384x384" href="/images/iajh.384.png"><link rel="apple-touch-icon" sizes="256x256" href="/images/iajh.256.png"><link rel="apple-touch-icon" sizes="192x192" href="/images/iajh.192.png"><link rel="apple-touch-icon" sizes="128x128" href="/images/iajh.128.png"></head><body><style type="text/css">@import '/style/classes/blog/index.css';
    </style><section class="blog blog-post astro-CXb8jdBr"><h1 class="latest astro-CXb8jdBr">Browses, Servers, and APIs</h1><main class="astro-CXb8jdBr"><img width="360" height="210" class="hero-image astro-CXb8jdBr" loading="lazy" src="/vendor/img/www.pexels.com/pixabay/view-of-street-from-a-glass-window.jpg" alt="Astro"><p class="publish-date astro-CXb8jdBr">1 May 2019</p><h1 class="title astro-CXb8jdBr">Browses, Servers, and APIs</h1><div class="author astro-CXb8jdBr"><p class="astro-CXb8jdBr"><a href="https://iamjohnhenry.com" class="astro-CXb8jdBr">John Henry</a></p></div><p><em>Originally Published: <a href="https://medium.com/@iamjohnhenry/browsers-servers-and-apis-2f7b10523f39">https://medium.com/@iamjohnhenry/browsers-servers-and-apis-2f7b10523f39</a></em></p><p>(Or “The path to Isomorphic Javascript”)</p><p>Note: Examples in the article were tested and run using <a href="https://nodejs.org/en/">node</a> and <a href="http://browserify.org/">browserify</a>.</p><p>If you’re a modern JavaScript enthusiast, you’re familiar with isomorphic code — the idea that you can write code that will run in both browser and node environments. Because JavaScript is a standardized language, you might think that this would be a trivial matter. The problem comes not in the language itself, but in the <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a>s, which are specific to each environment and not standardized to play well with others.</p><p>Some actions in one environment do not make sense in the other and so they lack specific APIs. The browser isn’t given access to the file system, so the <a href="https://nodejs.org/api/fs.html">fs object</a> that comes with node would not make sense here. Conversely, when I was younger, I would make copious use of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/alert">window.alert</a> for debugging, but a popup window won’t show up when you’re looking at a command line.</p><p>There are some actions, however, that can be done both within node and within the browser. One of the most interesting is creating servers.</p><h2 id="standardizing-servers"><strong>Standardizing Servers</strong></h2><p>Traditionally you wouldn’t set up a server within a browser, but considering what a server does — accepts requests and responds asynchronously, we can think of many use cases.</p><p>For instance, a server within a service worker would be able to intercept and respond to requests within the browser, without ever having to make a call across a network.</p><pre class=" language-html"><code class="language-html">//example -- service worker
const server = …;//define later

self.addEventListener(‘fetch’, function(event) {
 return event.respondWith(new Promise((resolve, reject)=&gt;{
   const response = server.respondTo(event.request);
   response.on(“finish”, ()=&gt;{
     resolve(req);
   });
 }));
});
</code></pre><p>We’ll come back to this idea…</p><h2 id="competing-standards"><strong>Competing Standards</strong></h2><p>So, I want to put a server in the browser — what are my options? Not long ago, I learned about the new <a href="https://hacks.mozilla.org/2016/09/flyweb-pure-web-cross-device-interaction/">FlyWeb</a> standard that <a href="https://blog.mozilla.org/">Mozilla</a> is pushing for creating servers within the browser. I was pretty excited until i realized how different it was from anything that already existed in node.</p><p>Every other server that I’ve seen follows a particular pattern…</p><h3 id="http"><strong>HTTP</strong></h3><p>Node already has a built in simple API for creating servers via <a href="https://nodejs.org/api/http.html">http</a>.</p><pre class=" language-html"><code class="language-html">//example -- http
//create server and define action
const server = require(“http”)
 .createServer((request, response)=&gt;{
  ...//process request
  response.end();//end response
});

//start server
server.listen(/*listening address*/);
</code></pre><p>This might be considered a standard, but many modern server applications are built to handle complex workflows.</p><h3 id="express"><strong>Express</strong></h3><p>As the http module is quite simplistic, the <a href="https://github.com/expressjs/express">express</a> module is the de-facto standard for creating servers within node. It separates creating the server from assigning it actions. It also makes handling complex workflows easier. Express servers have a “use” method. It allows the user to chain together multiple functions to act upon a request before a response is sent. These functions are called “middleware”.</p><pre class=" language-html"><code class="language-html">//example -- express

//create server
const server = require(“express”)();

//register middleware
server.use((request, response, next)=&gt;{
  ...//process request
  next();//go to next middleware
});

//register middleware
server.use((request, response, next)=&gt;{
  ...//process request
  if(request.endResponse){
    response.end();//end response
  }else{
    next();//go to next middleware
  }
});

//register middleware
server.use((request, response)=&gt;{
  response.end();//end response
});

//start server
server.listen(/*listening address*/);
</code></pre><p>In addition, express adds additional features such as templating or routing which you may or may not need.</p><h3 id="koa-2"><strong>Koa 2</strong></h3><p><a href="https://github.com/koajs/koa">Koa</a> was created by the same people who create express and is considered to be its spiritual successor. It’s also my server of choice, so you should <a href="http://koajs.com/">take a look at how it works</a> if you haven’t already.</p><p>Koa makes use of <a href="https://github.com/tc39/ecmascript-asyncawait">asynchronous functions</a> and adding middleware works similarly.</p><pre class=" language-html"><code class="language-html">//example -- koa

const server = require(“koa”)();

server.use(async (context, next)=&gt;{
  ...//process request
  next();//go to next middleware
});

server.use((context, next)=&gt;{
  context.res.end();//end response
});

//start server
server.listen(/*listening address*/);
</code></pre><p>Koa also eschews built in routing and templating in favor of including them externally as middleware.</p><p>Please be aware that Koa 2 is still in alpha, but since its API is so much cleaner than Koa 1’s, <a href="https://www.smashingmagazine.com/2016/08/getting-started-koa-2-async-functions/">here’s a tutorial that will help you jump right in</a>,</p><h3 id="rill"><strong>Rill</strong></h3><p><a href="https://github.com/rill-js/rill">Rill</a> is a <a href="https://medium.com/@pierceydylan/isomorphic-javascript-it-just-has-to-work-b9da5b0c8035#.l79bgqqwx">new server</a> that has basically the same API as KOA 2, but works in the browser as well as in node right out of the box.</p><pre class=" language-html"><code class="language-html">//example -- rill

const server = require(“rill”)();

server.use((context, next)=&gt;{
  context.res.end();//end response
});

server.listen(/*listening address*/);
</code></pre><p>Rill may be overkill for my purposes, as it includes routing features that manipulate the web page, in addition to simply processing requests into responses.</p><h3 id="flyweb"><strong>FlyWeb</strong></h3><p>There’s a basic pattern of that all of the other servers follow.</p><p>1 create server</p><p>2 add actions</p><p>3 start server</p><p>While rill or koa would have been a great starting point for a server in the browser, mozilla has taken a different route with their new FlyWeb servers.</p><pre class=" language-html"><code class="language-html">//example -- flyweb

//create and start server
const server = await window.navigator.publishServer(/*listening address*/);

//add actions
server.onfetch = (request)=&gt;{
  ...//process request
  request.end();//end response
};
</code></pre><p>This breaks the pattern of everything we’ve seen so far! Here the server is created and started first. Only afterwards are actions actions added.</p><p>Do we really need an entirely new way of doing basically the same thing?</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*9nMBMt-OugnruBr_M-WuEQ.png" alt="I know. It’s in every article. Perhaps that says something to the importance of the situation. https://xkcd.com/license.html"><em>I know. It’s in every article. Perhaps that says something to the importance of the situation. <a href="https://xkcd.com/license.html">https://xkcd.com/license.html</a></em></p><h2 id="rillhttp-to-the-rescue"><strong>@Rill/http to the Rescue</strong></h2><p><a href="https://medium.com/@pierceydylan/">The creators of rill are</a> pretty smart. When they created rill to work in the browser and in node, they realized the same thing I did at the beginning of this article — that dissimilar APIs are what make isomorphic code so difficult. So, to ensure that it works in both places, they created their own implementation of node’s low level <a href="https://nodejs.org/api/http.html">http module</a>, <a href="https://github.com/rill-js/http">@rill/http</a>, that works in the browser. Because it follows the same API, it can be, with a few tweaks, swapped into other modules that depend upon http, and allow them to work in the browser.</p><p>And that’s exactly what I’ve done with <a href="https://github.com/johnhenry/koa-2-browser">koa-2-browser</a>. It’s literally koa that works in the browser! It’s a light framework, so it integrates easily with other code. And because the changes are relatively minor, I’m working on landing these changes in an upcoming release of Koa as to make it an isomorphic application out of the box. For now, you can take [nearly] all code that you wrote for a koa server in node, and transfer it to the browser.</p><p>Revisiting the service worker example above, we have:</p><pre class=" language-html"><code class="language-html">//example -- koa-2-browser
const server = require(‘koa-2-browser’)();
server.use(/*middleware*/);
server.listen(()=&gt;{

self.onfetch(function(event) {
    return event.respondWith(new Promise((resolve, reject)=&gt;{
      const response = server.respondTo(event.request,{browserResponse:true});
      response.on(“finish”, (res)=&gt;{
        resolve(res);
      });
    }));
  });

});

//Note:server.RespondTo returns a response, (here identified as "response") object that is not a suitable resolution for the promise passed to event.respond with. Passing the "browserResponse:true" option will cause the "finish" event to be resolved with a suitable instance of window.Response (identified as "res").
</code></pre><p>It’s important to realize that if we ever want to move towards isomorphic JavaScript, we should really shy away from competing standards within the language itself.</p><p>And this is true for open source software as a whole; if two different APIs do the same thing, they should have the same structure. When we set out to create something new, we should pay attention to and work with others who are already doing similar things in other environments. The less time we spend re-inventing the wheel, the more time we have to invent new and exciting stuff (hover-wheel anyone?).</p><h2 id="et-tu-buffer">Et tu, Buffer?</h2><p>Servers aren’t the only competing standards across environments.</p><p><a href="https://nodejs.org/api/buffer.html">**Buffers</a>** are standardized in node and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">**ArrayBuffers</a>** are standardized in the browser. They are both containers for binary data, but they work slightly differently. This is particularly annoying when attempting to create isomorphic applications. Even worse, some objects that have a “buffer” method, may return an ArrayBuffer instead, meaning that you may have to apply special logic to work with them in different environments.</p><p>After many revisions, <a href="https://nodejs.org/api/stream.html">**Streams</a>** are close to full standardization in node. Unfortunately, <a href="https://streams.spec.whatwg.org/">**Browser Streams</a>**, an emerging standard, introduce new and incompatible parts of the API. Hopefully, the groups involved can come to an agreement at some point.</p><p>There are some other similar topics like <strong>importing modules</strong>, but that situation is way more complicated to go into her.</p><h2 id="bonus-library">Bonus Library!!!</h2><p>But trying new things is fun! I actually prefer the <a href="https://github.com/flyweb/spec">way that FlyWeb creates servers</a>. Since it <a href="https://github.com/koajs/koa/issues/482">it appears that I’m not the only one</a>, I’ve created another library, <a href="https://github.com/johnhenry/flyweb-koa">flyweb-koa</a>. It allows you to use koa in a manner similar to the FlyWeb, while maintaining everything that koa has to offer.</p><pre class=" language-html"><code class="language-html">const koa = require(“koa-2-browser”);
//This also works with koa;

const publishServer = require(‘flyweb-koa’)(‘koa’);

const server = await publishServer(/*listening address*/);
server.use(/*middleware*/);
server.onfetch = (context)=&gt;{
...
};
server.respondTo(/*request*/);
</code></pre></main></section><header><a href="/#"><img src="/image/iajh.png" width="16" height="16" alt="logo">John Henry</a><ul class="nav-list"><li><a href="/blog">Blog</a></li><li><a href="/#me">Me</a></li><li><a href="/#projects">Projects</a></li></ul></header><footer><ul><li class="nav-list"><a href="#">© 2021 John</a></li></ul></footer><span class="mouse-chaser" style="--mouse-z: var(--header-z)"></span></body></html>